# 实验2：页表与内存管理

## 任务一：深入理解Sv39页表机制

- 虚地址：
  - VPN 27位，三级页表，所以是3x9
  - offset，12位，4kB页面大小
- PTE：
  - 44位PPN
  - 10位标志位，其中：
        1. V：valid
        2. R：Readable
        3. W：Writable
        4. X：Executable
        5. U：User

## 任务二：分析xv6的物理内存分配器

- 核心数据结构`struct run`的好处：
  - 当`run`在空闲页面链表中时，其本身的地址就是对应的空闲页的起始地址，结构体成员`next`则指向下一个空白页面。
  - 当`run`从空闲页面链表取出时，则直接把它类型转换为指针，从而直接当作一个页的起始地址来使用。
- 分析 `kinit()` 的初始化过程：
  - 可分配内存范围：`end` ~ `PHYSTOP`
  - 构建空闲页面链表：将内存范围起始地址取整到页面大小的整数倍，然后在范围内一页一页得将空闲页面添加到链表
  - 按页对齐本身就是使用页表管理内存的核心思想，目的是提高内存的利用率，同时也能使内存管理更方便。
- 理解 `kalloc()` 和 `kfree()` 的实现：
  - `kalloc()`时间复杂度为O(1)
  - 防止double-free由上层协定，`kfree()`本身未做检测
  - 优点：底层便于使用，快速高效。 缺点：需要上层做异常判断和处理

## 任务三：设计你的物理内存管理器

无问题

## 任务四：理解xv6的页表管理

- 分析`walk()`函数的递归遍历
  - 3级页表，依次查询
  - 无效项根据是否有alloc参数来处理
  - `alloc`参数是多级页表的核心，只在必要的时候分配第2级和第3级页表
- `mappages()`映射建立
  - va和pa必须要按页对齐
  - 建立映射需要在上层提供的perm的基础上添加v权限位
  - 如果出现映射失败的情况，直接返回-1终止

## 任务五：实现你的页表管理系统

无问题

## 任务六：启用虚拟内存

无问题