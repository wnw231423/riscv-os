# 实验1：RISC-V引导与裸机启动
## 任务1： 理解xv6启动流程
- 为什么第一条指令是设置栈指针？
    - 为各CPU确定其栈的起始地址，方便后续运行c语言代码
- la sp, stack0 中的stack0在哪里定义？
    - 在`start.c`中定义. 因为`stack0`是全局变量, 经过链接之后, `entry.S`可以访问变量`stack0`.
- 为什么要清零BSS段？
    - 没找到哪儿清零BSS段
- 如何从汇编跳转到C函数？
    - 经过链接之后，汇编代码可以知道并访问c语言的函数，只要该函数未被`static`关键字修饰。
- ENTRY(_entry) 的作用是什么？
    - 让`_entry`对应的汇编代码作为os启动的入口
- 为什么代码段要放在0x80000000？
    - 根据xv6手册P28，该地址以下用于IO设备
- etext、edata、end 符号有什么用途？
    - 标记代码段，数据段，整个内核的结束位置
- xv6支持多核，你的单核系统可以如何简化？ 
    - 在启动时仅分配单个CPU的栈空间
- xv6的内存管理很复杂，最小系统需要哪些部分？
    - 需要以下部分：
        1. `entry.S`，为CPU设定栈起始地址，跳转到`start.c`执行c函数
        2. `start.c`，初始化，跳转到`main`函数
        3. `串口驱动`，让`main`函数输出字符
        4. `kernel.ld`，链接脚本