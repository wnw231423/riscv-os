# 实验1：RISC-V引导与裸机启动
## 任务1： 理解xv6启动流程
- 为什么第一条指令是设置栈指针？
    - 为各CPU确定其栈的起始地址，方便后续运行c语言代码
- la sp, stack0 中的stack0在哪里定义？
    - 在`start.c`中定义. 因为`stack0`是全局变量, 经过链接之后, `entry.S`可以访问变量`stack0`.
- 为什么要清零BSS段？
    - 没找到哪儿清零BSS段
- 如何从汇编跳转到C函数？
    - 经过链接之后，汇编代码可以知道并访问c语言的函数，只要该函数未被`static`关键字修饰。
- ENTRY(_entry) 的作用是什么？
    - 让`_entry`对应的汇编代码作为os启动的入口
- 为什么代码段要放在0x80000000？
    - 根据xv6手册P28，该地址以下用于IO设备
- etext、edata、end 符号有什么用途？
    - 标记代码段，数据段，整个内核的结束位置
- xv6支持多核，你的单核系统可以如何简化？ 
    - 在启动时仅分配单个CPU的栈空间
- xv6的内存管理很复杂，最小系统需要哪些部分？
    - 需要以下部分：
        1. `entry.S`，为CPU设定栈起始地址，跳转到`start.c`执行c函数
        2. `start.c`，初始化，跳转到`main`函数
        3. `main.c`
        3. `uart.c`，让`main`函数输出字符串
        4. `kernel.ld`，链接脚本
## 任务2： 设计最小启动流程
- 启动流程图：
    entry.S -> start.c -> main.c
- 内存布局
    高
    bss段, (包括stack0)
    data段
    text段
    0x80000000
    0x10000000 (UART0)
    低
- 硬件初始化
    1. 串口初始化
    2. M模式转到S模式后，需要做初始化
- 栈应该放在内存的哪个位置？需要多大？
    - 未初始化，故位于bss段
- 是否需要清零BSS段？为什么？
    - 不需要，bss段只有栈，使用栈不需要提前清零
- 最简单串口输出需要配置哪些寄存器？
    - THR， LCR
## 任务3：实现启动汇编代码
无问题
## 任务4：编写链接脚本
无问题
## 任务5：实现串口驱动
-  输出一个字符的完整流程 
    - 设备初始化
    - 检测LCR的THR empty flag是否为1， 是则写入THR，否则等待
- 为什么需要检查LSR的THRE位？
    - 根据[资料](http://byterunner.com/16550.html)，必须在LCR的empty flag为1时，才能向THR写入
## 任务6： 完成C主函数
- 程序结束后应该做什么？死循环还是关机？
    - 死循环
- 如何防止程序意外退出导致系统重启？
    - 未知